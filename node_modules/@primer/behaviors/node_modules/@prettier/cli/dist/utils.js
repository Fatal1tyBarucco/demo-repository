import findUp from "find-up-json";
import { moduleResolve } from "import-meta-resolve";
import crypto from "node:crypto";
import fs from "node:fs";
import path from "node:path";
import process from "node:process";
import url from "node:url";
import { exit } from "specialist";
import readdir from "tiny-readdir-glob";
import zeptomatch from "zeptomatch";
//FIXME: Ensure all arguments are actually taken into account
//TODO: Publish something like this as a standalone module, rather than manually hoisting this up
function memoize(fn) {
    const memoized = (...args) => {
        const { cache } = memoized;
        const id = args[0];
        const cached = cache.get(id);
        if (!isUndefined(cached) || cache.has(id))
            return cached;
        const result = fn(...args);
        cache.set(id, result);
        return result;
    };
    memoized.cache = new Map();
    return memoized;
}
function castArray(value) {
    return isArray(value) ? value : [value];
}
function everyOf(fns) {
    return (arg) => {
        return fns.every((fn) => fn(arg));
    };
}
function fastJoinedPath(folderPath, fileName) {
    return `${folderPath}${path.sep}${fileName}`;
}
function fastRelativePath(fromPath, toPath) {
    if (toPath.startsWith(fromPath)) {
        if (toPath[fromPath.length] === path.sep) {
            return toPath.slice(fromPath.length + 1);
        }
    }
    return path.relative(fromPath, toPath);
}
function fastRelativeChildPath(fromPath, toPath) {
    if (toPath.startsWith(fromPath)) {
        if (toPath[fromPath.length] === path.sep) {
            return toPath.slice(fromPath.length + 1);
        }
    }
}
function findLastIndex(array, predicate) {
    for (let i = array.length - 1; i >= 0; i--) {
        if (predicate(array[i], i, array))
            return i;
    }
    return -1;
}
function getCachePath(rootPath) {
    const nodeModulesPaths = path.join(rootPath, "node_modules");
    const cachePath = path.join(nodeModulesPaths, ".cache", "prettier", ".prettier-caches");
    return cachePath;
}
function getExpandedFoldersPaths(foldersPaths, untilPath = "/") {
    const knownPaths = new Set(foldersPaths);
    const expandedPaths = new Set();
    const extraPaths = new Set();
    for (let i = 0, l = foldersPaths.length; i < l; i++) {
        let folderPath = foldersPaths[i];
        while (true) {
            if (expandedPaths.has(folderPath))
                break;
            if (folderPath === untilPath)
                break;
            expandedPaths.add(folderPath);
            folderPath = path.dirname(folderPath);
            if (!knownPaths.has(folderPath)) {
                extraPaths.add(folderPath);
            }
        }
    }
    return [[...expandedPaths], [...extraPaths]];
}
async function getFolderChildrenPaths(folderPath) {
    const dirents = await fs.promises.readdir(folderPath, { withFileTypes: true });
    const childrenPaths = dirents.map((dirent) => fastJoinedPath(folderPath, dirent.name));
    return childrenPaths;
}
async function getFoldersChildrenPaths(foldersPaths) {
    const childrensPaths = await Promise.all(foldersPaths.map(getFolderChildrenPaths));
    const childrenPaths = childrensPaths.flat();
    return childrenPaths;
}
function getGlobPaths(rootPath, globs, withNodeModules) {
    return readdir(globs, {
        cwd: rootPath,
        followSymlinks: false,
        ignore: `**/{.git,.sl,.svn,.hg,.DS_Store,Thumbs.db${withNodeModules ? "" : ",node_modules"}}`,
    });
}
async function getModule(modulePath) {
    const moduleExports = await import(modulePath);
    const module = moduleExports.default || moduleExports.exports || moduleExports;
    return module;
}
function getModulePath(name, rootPath) {
    const rootUrl = url.pathToFileURL(rootPath);
    const moduleUrl = moduleResolve(name, rootUrl);
    const modulePath = url.fileURLToPath(moduleUrl);
    return modulePath;
}
const getPlugin = memoize((name) => {
    const pluginPath = getPluginPath(name);
    const plugin = getModule(pluginPath);
    return plugin;
});
function getPluginPath(name) {
    const rootPath = path.join(process.cwd(), "index.js");
    const pluginPath = getModulePath(name, rootPath);
    return pluginPath;
}
function getPluginVersion(name) {
    const pluginPath = getPluginPath(name);
    const parentPath = path.dirname(pluginPath);
    const pkg = findUp("package.json", parentPath);
    if (!pkg || !pkg.content.version)
        throw new Error(`Version not found for plugin: "${name}"`);
    return pkg.content.version;
}
function getPlugins(names) {
    if (!names.length)
        return [];
    return Promise.all(names.map(getPlugin));
}
function getPluginsPaths(names) {
    const pluginsPaths = names.map(getPluginPath);
    return pluginsPaths;
}
function getPluginsVersions(names) {
    const pluginsVersions = names.map(getPluginVersion);
    return pluginsVersions;
}
function getProjectPath(rootPath) {
    function isProjectPath(folderPath) {
        const gitPath = path.join(folderPath, ".git");
        if (fs.existsSync(gitPath))
            return true;
        const hgPath = path.join(folderPath, ".hg");
        if (fs.existsSync(hgPath))
            return true;
        return false;
    }
    let currentPath = rootPath;
    while (true) {
        if (isProjectPath(currentPath)) {
            return currentPath;
        }
        else {
            const currentPathNext = path.dirname(currentPath);
            if (currentPath === currentPathNext) {
                return rootPath;
            }
            else {
                currentPath = currentPathNext;
            }
        }
    }
}
async function getTargetsPaths(rootPath, globs, withNodeModules) {
    const targetFiles = [];
    const targetFilesNames = [];
    const targetFilesNamesToPaths = {};
    const targetGlobs = [];
    for (const glob of globs) {
        const filePath = path.resolve(rootPath, glob);
        if (isFile(filePath)) {
            const fileName = path.basename(filePath);
            targetFiles.push(filePath);
            targetFilesNames.push(fileName);
            targetFilesNamesToPaths.propertyIsEnumerable(fileName) || (targetFilesNamesToPaths[fileName] = []);
            targetFilesNamesToPaths[fileName].push(filePath);
        }
        else {
            targetGlobs.push(glob);
        }
    }
    const result = await getGlobPaths(rootPath, targetGlobs, withNodeModules);
    const filesPaths = [...targetFiles, ...result.files];
    const filesNames = [...targetFilesNames, ...result.filesFoundNames];
    const filesNamesToPaths = result.filesFoundNamesToPaths;
    for (const fileName in targetFilesNamesToPaths) {
        const prev = filesNamesToPaths[fileName];
        const next = Array.isArray(prev) ? prev.concat(targetFilesNamesToPaths[fileName]) : targetFilesNamesToPaths[fileName];
        filesNamesToPaths[fileName] = uniq(next);
    }
    const filesFoundPaths = result.filesFound;
    const foldersFoundPaths = [rootPath, ...result.directoriesFound];
    return [filesPaths, filesNames, filesNamesToPaths, filesFoundPaths, foldersFoundPaths];
}
function isArray(value) {
    return Array.isArray(value);
}
function isBoolean(value) {
    return typeof value === "boolean";
}
function isFalsy(value) {
    return !value;
}
function isFile(targetPath) {
    try {
        const stats = fs.statSync(targetPath);
        return stats.isFile();
    }
    catch {
        return false;
    }
}
function isFunction(value) {
    return typeof value === "function";
}
function isGlobStatic(glob) {
    //TODO: Make this perfect, grammar-based, rather than letting some glob-looking paths slip through
    return /^(?:\\.|[ a-zA-Z0-9/._-])*$/.test(glob);
}
function isInteger(value) {
    return Number.isInteger(value);
}
function isNumber(value) {
    return typeof value === "number";
}
function isObject(value) {
    if (value === null)
        return false;
    const type = typeof value;
    return type === "object" || type === "function";
}
function isPromise(value) {
    return value instanceof Promise;
}
function isString(value) {
    return typeof value === "string";
}
function isTruthy(value) {
    return !!value;
}
function isUndefined(value) {
    return typeof value === "undefined";
}
function negate(fn) {
    return (...args) => {
        return !fn(...args);
    };
}
function noop() {
    return;
}
function normalizeOptions(options, targets) {
    if (!isObject(options))
        exit("Invalid options object");
    const targetsGlobs = targets.filter(isString);
    const targetsStatic = "--" in options && Array.isArray(options["--"]) ? options["--"].filter(isString).map(zeptomatch.escape) : [];
    const globs = [...targetsGlobs, ...targetsStatic];
    if (!globs.length)
        exit("Expected at least one target file/dir/glob");
    const check = "check" in options && !!options.check;
    const list = "listDifferent" in options && !!options.listDifferent;
    const write = "write" in options && !!options.write;
    if (check && list)
        exit('The "--check" and "--list-different" flags cannot be used together');
    if (check && write)
        exit('The "--check" and "--write" flags cannot be used together');
    if (list && write)
        exit('The "--list-different" and "--write" flags cannot be used together');
    const config = "config" in options ? !!options.config : true;
    const configPath = "configPath" in options && isString(options.configPath) ? [options.configPath] : undefined;
    const editorConfig = "editorconfig" in options ? !!options.editorconfig : true;
    const ignorePath = "ignorePath" in options && isArray(options.ignorePath) && options.ignorePath.every(isString) ? options.ignorePath : undefined;
    const withNodeModules = "withNodeModules" in options ? !!options.withNodeModules : false;
    const cache = "cache" in options ? !!options.cache : true;
    const cacheLocation = "cacheLocation" in options && isString(options.cacheLocation) ? options.cacheLocation : undefined;
    const errorOnUnmatchedPattern = "errorOnUnmatchedPattern" in options ? !!options.errorOnUnmatchedPattern : true;
    const ignoreUnknown = "ignoreUnknown" in options && isBoolean(options.ignoreUnknown) ? !!options.ignoreUnknown : globs.some(isGlobStatic);
    const logLevel = "logLevel" in options ? (options.logLevel || "log") : "log";
    const parallel = "parallel" in options && !!options.parallel;
    const parallelWorkers = ("parallelWorkers" in options && Math.round(Number(options.parallelWorkers))) || 0;
    const contextOptions = normalizeContextOptions(options);
    const formatOptions = normalizeFormatOptions(options);
    return {
        globs,
        check,
        list,
        write,
        config,
        configPath,
        editorConfig,
        ignorePath,
        withNodeModules,
        cache,
        cacheLocation,
        errorOnUnmatchedPattern,
        ignoreUnknown,
        logLevel,
        parallel,
        parallelWorkers,
        contextOptions,
        formatOptions,
    };
}
function normalizeContextOptions(options) {
    if (!isObject(options))
        exit("Invalid options object");
    const contextOptions = {};
    if ("cursorOffset" in options) {
        const value = Number(options.cursorOffset);
        if (isInteger(value) && value >= 0) {
            contextOptions.cursorOffset = value;
        }
    }
    if ("rangeEnd" in options) {
        const value = Number(options.rangeEnd);
        if (isInteger(value) && value >= 0) {
            contextOptions.rangeEnd = value;
        }
    }
    if ("rangeStart" in options) {
        const value = Number(options.rangeStart);
        if (isInteger(value) && value >= 0) {
            contextOptions.rangeStart = value;
        }
    }
    return contextOptions;
}
function normalizeFormatOptions(options) {
    if (!isObject(options))
        exit("Invalid options object");
    const formatOptions = {};
    if ("experimentalTernaries" in options) {
        const value = options.experimentalTernaries;
        if (isBoolean(value)) {
            formatOptions.experimentalTernaries = value;
        }
    }
    if ("arrowParens" in options) {
        const value = options.arrowParens;
        if (value === "avoid" || value === "always") {
            formatOptions.arrowParens = value;
        }
    }
    if ("bracketSameLine" in options) {
        const value = options.bracketSameLine;
        if (isBoolean(value)) {
            formatOptions.bracketSameLine = value;
        }
    }
    if ("bracketSpacing" in options) {
        const value = options.bracketSpacing;
        if (isBoolean(value)) {
            formatOptions.bracketSpacing = value;
        }
    }
    if ("embeddedLanguageFormatting" in options) {
        const value = options.embeddedLanguageFormatting;
        if (value === "auto" || value === "off") {
            formatOptions.embeddedLanguageFormatting = value;
        }
    }
    if ("endOfLine" in options) {
        const value = options.endOfLine;
        if (value === "lf" || value === "crlf" || value === "cr" || value === "auto") {
            formatOptions.endOfLine = value;
        }
    }
    if ("htmlWhitespaceSensitivity" in options) {
        const value = options.htmlWhitespaceSensitivity;
        if (value === "css" || value === "strict" || value === "ignore") {
            formatOptions.htmlWhitespaceSensitivity = value;
        }
    }
    if ("insertPragma" in options) {
        const value = options.insertPragma;
        if (isBoolean(value)) {
            formatOptions.insertPragma = value;
        }
    }
    if ("jsxSingleQuote" in options) {
        const value = options.jsxSingleQuote;
        if (isBoolean(value)) {
            formatOptions.jsxSingleQuote = value;
        }
    }
    if ("parser" in options) {
        const value = options.parser;
        // prettier-ignore
        if (value === "flow" || value === "babel" || value === "babel-flow" || value === "babel-ts" || value === "typescript" || value === "acorn" || value === "espree" || value === "meriyah" || value === "css" || value === "less" || value === "scss" || value === "json" || value === "json5" || value === "json-stringify" || value === "graphql" || value === "markdown" || value === "mdx" || value === "vue" || value === "yaml" || value === "glimmer" || value === "html" || value === "angular" || value === "lwc") {
            formatOptions.parser = value;
        }
    }
    if ("plugin" in options || "plugins" in options) {
        const value = options["plugin"] || options["plugins"];
        if (isArray(value) && value.every(isString)) {
            formatOptions.plugins = value;
        }
        else if (isString(value)) {
            formatOptions.plugins = [value];
        }
        else if (!isUndefined(value)) {
            //TODO: Figure out what to do here, probably just bailing out of parallelization?
            exit("Non-string plugin specifiers are not supported yet");
        }
    }
    if ("printWidth" in options) {
        const value = Number(options.printWidth);
        if (isInteger(value) && value >= 0) {
            formatOptions.printWidth = value;
        }
    }
    if ("proseWrap" in options) {
        const value = options.proseWrap;
        if (value === "always" || value === "never" || value === "preserve") {
            formatOptions.proseWrap = value;
        }
    }
    if ("quoteProps" in options) {
        const value = options.quoteProps;
        if (value === "as-needed" || value === "consistent" || value === "preserve") {
            formatOptions.quoteProps = value;
        }
    }
    if ("requirePragma" in options) {
        const value = options.requirePragma;
        if (isBoolean(value)) {
            formatOptions.requirePragma = value;
        }
    }
    if ("semi" in options) {
        const value = options.semi;
        if (isBoolean(value)) {
            formatOptions.semi = value;
        }
    }
    if ("singleAttributePerLine" in options) {
        const value = options.singleAttributePerLine;
        if (isBoolean(value)) {
            formatOptions.singleAttributePerLine = value;
        }
    }
    if ("singleQuote" in options) {
        const value = options.singleQuote;
        if (isBoolean(value)) {
            formatOptions.singleQuote = value;
        }
    }
    if ("tabWidth" in options) {
        const value = Number(options.tabWidth);
        if (isInteger(value) && value >= 0) {
            formatOptions.tabWidth = value;
        }
    }
    if ("trailingComma" in options) {
        const value = options.trailingComma;
        if (value === "all" || value === "es5" || value === "none") {
            formatOptions.trailingComma = value;
        }
    }
    if ("useTabs" in options) {
        const value = options.useTabs;
        if (isBoolean(value)) {
            formatOptions.useTabs = value;
        }
    }
    if ("vueIndentScriptAndStyle" in options) {
        const value = options.vueIndentScriptAndStyle;
        if (isBoolean(value)) {
            formatOptions.vueIndentScriptAndStyle = value;
        }
    }
    return formatOptions;
}
function normalizePluginOptions(options, names) {
    if (!isObject(options))
        exit("Invalid options object");
    const config = {};
    for (let i = 0, l = names.length; i < l; i++) {
        const name = names[i];
        const value = options[name];
        if (isUndefined(value))
            continue;
        config[name] = value;
    }
    return config;
}
function normalizePrettierOptions(options, folderPath) {
    if (!isObject(options))
        exit("Invalid options object");
    const config = normalizeFormatOptions(options);
    if ("overrides" in options && isArray(options.overrides)) {
        const overridesRaw = options.overrides;
        for (let i = 0, l = overridesRaw.length; i < l; i++) {
            const overrideRaw = overridesRaw[i];
            if (!isObject(overrideRaw))
                continue;
            if (!("files" in overrideRaw))
                continue;
            if (!isString(overrideRaw.files) && (!isArray(overrideRaw.files) || !overrideRaw.files.every(isString)))
                continue;
            if (isArray(overrideRaw.files) && !overrideRaw.files.length)
                continue;
            if (!("options" in overrideRaw))
                continue;
            if (!isObject(overrideRaw.options))
                continue;
            const overrides = (config.overrides || (config.overrides = []));
            const filesPositive = castArray(overrideRaw.files);
            const filesNegative = "filesNegative" in overrideRaw && (isString(overrideRaw.filesNegative) || (isArray(overrideRaw.filesNegative) && overrideRaw.filesNegative.every(isString))) ? castArray(overrideRaw.filesNegative) : []; // prettier-ignore
            const folder = folderPath;
            const options = normalizeFormatOptions(overrideRaw.options);
            overrides.push({ filesPositive, filesNegative, folder, options });
        }
    }
    return config;
}
function omit(object, keys) {
    const clone = { ...object };
    for (let i = 0, l = keys.length; i < l; i++) {
        delete clone[keys[i]];
    }
    return clone;
}
function once(fn) {
    let inited = false;
    let result;
    return () => {
        if (!inited) {
            inited = true;
            result = fn();
        }
        return result;
    };
}
function pluralize(value, length) {
    return `${value}${length === 1 ? "" : "s"}`;
}
function resolve(value) {
    return isFunction(value) ? value() : value;
}
function sha1hex(value) {
    return crypto.createHash("sha1").update(value).digest("hex");
}
function sha1base64(value) {
    return crypto.createHash("sha1").update(value).digest("base64");
}
function someOf(fns) {
    return (arg) => {
        return fns.some((fn) => fn(arg));
    };
}
function uniq(values) {
    if (values.length < 2)
        return values;
    return Array.from(new Set(values));
}
function zipObject(keys, values) {
    const map = {};
    for (let i = 0, l = keys.length; i < l; i++) {
        map[keys[i]] = values[i];
    }
    return map;
}
function zipObjectUnless(keys, values, unless) {
    const map = {};
    for (let i = 0, l = keys.length; i < l; i++) {
        const value = values[i];
        if (!unless(value)) {
            map[keys[i]] = value;
        }
    }
    return map;
}
export { castArray, everyOf, fastJoinedPath, fastRelativePath, fastRelativeChildPath, findLastIndex, getCachePath, getFolderChildrenPaths, getFoldersChildrenPaths, getExpandedFoldersPaths, getGlobPaths, getModule, getModulePath, getPlugin, getPluginPath, getPluginVersion, getPlugins, getPluginsPaths, getPluginsVersions, getProjectPath, getTargetsPaths, isArray, isBoolean, isFalsy, isFunction, isInteger, isNumber, isObject, isPromise, isString, isTruthy, isUndefined, memoize, negate, noop, normalizeOptions, normalizeFormatOptions, normalizePluginOptions, normalizePrettierOptions, omit, once, pluralize, resolve, sha1hex, sha1base64, someOf, uniq, zipObject, zipObjectUnless, };
