import fs from "node:fs";
import path from "node:path";
import { fastRelativePath, getCachePath, isArray, isBoolean, isObject, isString, isUndefined, sha1hex, sha1base64 } from "./utils.js";
//TODO: Maybe remember thrown errors also, if they are under a certain size
class Cache {
    constructor(version, rootPath, options, logger) {
        this.version = sha1hex(version);
        this.logger = logger;
        this.rootPath = rootPath;
        this.storePath = options.cacheLocation || path.join(getCachePath(rootPath), `${sha1hex(rootPath)}.json`);
        this.store = this.read();
        this.dirty = false;
    }
    cleanup(store) {
        //TODO: Use a more sophisticated cleanup logic
        for (const version in store) {
            if (version === this.version)
                continue;
            delete store[version];
            this.dirty = true;
        }
        return store;
    }
    read() {
        try {
            const store = JSON.parse(fs.readFileSync(this.storePath, "utf8"));
            if (!isObject(store))
                return {};
            return this.cleanup(store);
        }
        catch (error) {
            this.logger.prefixed.debug(String(error));
            return {};
        }
    }
    write() {
        if (!this.dirty)
            return;
        try {
            const store = JSON.stringify(this.store);
            fs.mkdirSync(path.dirname(this.storePath), { recursive: true });
            fs.writeFileSync(this.storePath, store);
        }
        catch (error) {
            this.logger.prefixed.debug(String(error));
        }
    }
    get(filePath) {
        const fileRelativePath = fastRelativePath(this.rootPath, filePath);
        const save = this.set.bind(this, filePath, fileRelativePath);
        try {
            const file = this.store[this.version]?.files?.[fileRelativePath];
            if (!file || !isArray(file) || file.length !== 2)
                return { save };
            const [hash, formatted] = file;
            if (!isString(hash) || !isBoolean(formatted))
                return { save };
            const content = fs.readFileSync(filePath);
            const fileHash = sha1base64(content);
            if (hash !== fileHash)
                return { content, save };
            return { formatted, content, save };
        }
        catch (error) {
            this.logger.prefixed.debug(String(error));
            return { save };
        }
    }
    set(filePath, fileRelativePath, fileFormatted, fileContentExpected) {
        var _a, _b;
        try {
            const version = ((_a = this.store)[_b = this.version] || (_a[_b] = {}));
            const files = (version.files || (version.files = {}));
            //TODO: Skip the following hash if the expected content we got is the same one that we had
            const hash = sha1base64(fileContentExpected);
            version.modified = Date.now();
            files[fileRelativePath] = [hash, fileFormatted];
            this.dirty = true;
        }
        catch (error) {
            this.logger.prefixed.debug(String(error));
        }
    }
    async has(filePath, isIgnored) {
        var _a, _b;
        const fileRelativePath = fastRelativePath(this.rootPath, filePath);
        const file = this.store[this.version]?.files?.[fileRelativePath];
        if (isUndefined(file)) {
            const ignored = await isIgnored();
            if (ignored) {
                const version = ((_a = this.store)[_b = this.version] || (_a[_b] = {}));
                const files = (version.files || (version.files = {}));
                files[fileRelativePath] = false;
                this.dirty = true;
                return false;
            }
            else {
                return true;
            }
        }
        else {
            return !!file;
        }
    }
}
export default Cache;
