import type { FormatOptions, FunctionMaybe, Key, Options, PrettierConfigWithOverrides, PrettierPlugin } from "./types.js";
import type { PluginsOptions, PromiseMaybe } from "./types.js";
declare function memoize<Args extends unknown[], Return>(fn: (...args: Args) => Return): ((...args: Args) => Return) & {
    cache: Map<Args[0], Return>;
};
declare function castArray<T>(value: T | T[]): T[];
declare function everyOf<T>(fns: ((arg: T) => unknown)[]): (arg: T) => boolean;
declare function fastJoinedPath(folderPath: string, fileName: string): string;
declare function fastRelativePath(fromPath: string, toPath: string): string;
declare function fastRelativeChildPath(fromPath: string, toPath: string): string | undefined;
declare function findLastIndex<T>(array: T[], predicate: (value: T, index: number, array: T[]) => unknown): number;
declare function getCachePath(rootPath: string): string;
declare function getExpandedFoldersPaths(foldersPaths: string[], untilPath?: string): [string[], string[]];
declare function getFolderChildrenPaths(folderPath: string): Promise<string[]>;
declare function getFoldersChildrenPaths(foldersPaths: string[]): Promise<string[]>;
declare function getGlobPaths(rootPath: string, globs: string[], withNodeModules: boolean): Promise<import("tiny-readdir-glob/dist/types.js").Result>;
declare function getModule<T = unknown>(modulePath: string): Promise<T>;
declare function getModulePath(name: string, rootPath: string): string;
declare const getPlugin: ((name: string) => Promise<import("prettier").Plugin<any>>) & {
    cache: Map<string, Promise<import("prettier").Plugin<any>>>;
};
declare function getPluginPath(name: string): string;
declare function getPluginVersion(name: string): string;
declare function getPlugins(names: string[]): PromiseMaybe<PrettierPlugin[]>;
declare function getPluginsPaths(names: string[]): string[];
declare function getPluginsVersions(names: string[]): string[];
declare function getProjectPath(rootPath: string): string;
declare function getTargetsPaths(rootPath: string, globs: string[], withNodeModules: boolean): Promise<[string[], string[], Record<string, string[]>, string[], string[]]>;
declare function isArray(value: unknown): value is unknown[];
declare function isBoolean(value: unknown): value is boolean;
declare function isFalsy<T>(value: T): value is Extract<T, 0 | -0 | 0n | -0n | "" | false | null | undefined | void>;
declare function isFunction(value: unknown): value is Function;
declare function isInteger(value: unknown): value is number;
declare function isNumber(value: unknown): value is number;
declare function isObject(value: unknown): value is object;
declare function isPromise(value: unknown): value is Promise<unknown>;
declare function isString(value: unknown): value is string;
declare function isTruthy<T>(value: T): value is Exclude<T, 0 | -0 | 0n | -0n | "" | false | null | undefined | void>;
declare function isUndefined(value: unknown): value is undefined;
declare function negate<T extends unknown[]>(fn: (...args: T) => boolean): (...args: T) => boolean;
declare function noop(): undefined;
declare function normalizeOptions(options: unknown, targets: unknown[]): Options;
declare function normalizeFormatOptions(options: unknown): FormatOptions;
declare function normalizePluginOptions(options: unknown, names: string[]): PluginsOptions;
declare function normalizePrettierOptions(options: unknown, folderPath: string): PrettierConfigWithOverrides;
declare function omit<T extends object, K extends keyof T>(object: T, keys: K[]): Omit<T, K>;
declare function once<T>(fn: () => T): () => T;
declare function pluralize(value: string, length: number): string;
declare function resolve<T>(value: FunctionMaybe<T>): T;
declare function sha1hex(value: Uint8Array | string): string;
declare function sha1base64(value: Uint8Array | string): string;
declare function someOf<T>(fns: ((arg: T) => unknown)[]): (arg: T) => boolean;
declare function uniq<T>(values: T[]): T[];
declare function zipObject<T extends Key, U>(keys: T[], values: U[]): Partial<Record<T, U>>;
declare function zipObjectUnless<T extends Key, U>(keys: T[], values: U[], unless: (value: U) => boolean): Partial<Record<T, U>>;
export { castArray, everyOf, fastJoinedPath, fastRelativePath, fastRelativeChildPath, findLastIndex, getCachePath, getFolderChildrenPaths, getFoldersChildrenPaths, getExpandedFoldersPaths, getGlobPaths, getModule, getModulePath, getPlugin, getPluginPath, getPluginVersion, getPlugins, getPluginsPaths, getPluginsVersions, getProjectPath, getTargetsPaths, isArray, isBoolean, isFalsy, isFunction, isInteger, isNumber, isObject, isPromise, isString, isTruthy, isUndefined, memoize, negate, noop, normalizeOptions, normalizeFormatOptions, normalizePluginOptions, normalizePrettierOptions, omit, once, pluralize, resolve, sha1hex, sha1base64, someOf, uniq, zipObject, zipObjectUnless, };
