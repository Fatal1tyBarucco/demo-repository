"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRule = void 0;
const axe_core_1 = require("axe-core");
const interactiveElements = ['a[href]', 'button', 'summary', 'select', 'input:not([type=hidden])', 'textarea'];
const focusableElements = interactiveElements.concat(['[tabindex]']);
const generatedChecks = [];
const generatedRules = [];
createRule({
    id: 'menuitem-should-be-interactive',
    selector: 'div[role="menuitem"], span[role="menuitem"], div[role="menuitemradio"], span[role="menuitemradio"], div[role="menuitemcheckbox"], span[role="menuitemcheckbox"]',
    help: 'Menu items must be focusable. Use <button>, <a>, or <label tabindex="0">',
    checks: [
        (el) => focusableElements.filter(s => el.matches(s)).length > 0,
    ],
});
createRule({
    id: 'empty-summary',
    selector: 'summary',
    help: 'Details summary element must have visible text',
    any: ['has-visible-text', 'aria-label', 'aria-labelledby', 'role-presentation', 'role-none', 'non-empty-title'],
});
createRule({
    id: 'submit-reset-button-must-be-in-form',
    selector: 'button[type="submit"], button[type="reset"], input[type="submit"], input[type="reset"]',
    help: 'Submit and reset buttons must be in a form',
    checks: [
        el => {
            const formId = el.getAttribute('form');
            return !!el.closest('form') || !!(formId && document.getElementById(formId));
        },
    ],
});
createRule({
    id: 'nested-forms',
    selector: 'form',
    help: 'Nested form is invalid HTML and should be avoided',
    helpUrl: 'https://html.spec.whatwg.org/multipage/forms.html#the-form-element:concept-element-content-model',
    checks: [
        el => {
            return !(el.parentElement && el.parentElement.closest('form'));
        },
    ],
});
createRule({
    id: 'avoid-both-disabled-and-aria-disabled',
    selector: '[disabled][aria-disabled]',
    help: '[aria-disabled] may be used in place of native HTML [disabled] to allow tab-focus on an otherwise ignored element. Setting both attributes is contradictory.',
    helpUrl: 'https://www.w3.org/TR/html-aria/#docconformance-attr',
    checks: [
        () => {
            return false;
        },
    ],
});
createRule({
    id: 'aria-attribute-is-valid',
    selector: '[aria_label], [aria_labelledby], [aria_describedby], [aria_hidden], [aria_selected], [aria_checked], [aria_haspopup]',
    help: 'aria attributes should use a dash instead of an underscore. (e.g. [aria-label] instead of [aria_label])',
    checks: [
        () => false,
    ],
});
createRule({
    id: 'autofocus-in-dialog',
    excludeHidden: true,
    selector: 'modal-dialog, [role="dialog"], dialog',
    help: "Make sure there aren't multiple non-hidden elements with `autofocus` in your dialog",
    checks: [
        el => {
            const elementsWithAutofocus = el.querySelectorAll('[autofocus]');
            let autofocusCount = 0;
            for (const autofocus of elementsWithAutofocus) {
                const dom = axe_core_1.default.commons.dom;
                if (dom.isVisible(autofocus)) {
                    autofocusCount += 1;
                }
            }
            return autofocusCount <= 1;
        },
    ],
});
createRule({
    id: 'redundant-aria-label-aria-labelledby',
    excludeHidden: true,
    selector: '[aria-label][aria-labelledby]',
    help: 'An element should not have both [aria-label] and [aria-labelledby] attribute',
    impact: 'minor',
    checks: [
        () => {
            return false;
        },
    ],
});
function createRule({ id, excludeHidden = true, selector, checks = [], all = [], any = [], help, helpUrl = '', impact = 'critical', }) {
    if (/[^,] /.test(selector)) {
        console.warn('Try to avoid nested CSS selectors in `createRule`: %o', selector);
    }
    if (checks) {
        checks.map((func, i) => {
            const checkId = `${id}_${i}`;
            if (all)
                all.push(checkId);
            generatedChecks.push({
                id: checkId,
                evaluate: func,
                metadata: { impact },
            });
        });
    }
    generatedRules.push({ id, excludeHidden, selector, all, any, metadata: { help, helpUrl }, tags: ['custom-github-rule'] });
}
exports.createRule = createRule;
exports.default = {
    rules: generatedRules,
    checks: generatedChecks,
};
