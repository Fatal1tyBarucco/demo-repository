import { registerTag, observeElementForTags, parseElementTags } from './tag-observer.js';
import { controllable, attachShadowCallback } from './controllable.js';
import { createAbility } from './ability.js';
const parseActionAttribute = (tag) => {
    const eventSep = tag.lastIndexOf(':');
    const methodSep = Math.max(0, tag.lastIndexOf('#')) || tag.length;
    return [tag.slice(eventSep + 1, methodSep), tag.slice(0, eventSep), tag.slice(methodSep + 1) || 'handleEvent'];
};
registerTag('data-action', parseActionAttribute, (el, controller, tag, event) => {
    el.addEventListener(event, handleEvent);
});
const actionables = new WeakSet();
// Bind a single function to all events to avoid anonymous closure performance penalty.
function handleEvent(event) {
    const el = event.currentTarget;
    for (const [tag, type, method] of parseElementTags(el, 'data-action', parseActionAttribute)) {
        if (event.type === type) {
            const controller = el.closest(tag);
            if (actionables.has(controller) && typeof controller[method] === 'function') {
                controller[method](event);
            }
            const root = el.getRootNode();
            if (root instanceof ShadowRoot) {
                const shadowController = root.host;
                if (shadowController.matches(tag) && actionables.has(shadowController)) {
                    if (typeof shadowController[method] === 'function') {
                        shadowController[method](event);
                    }
                }
            }
        }
    }
}
export const actionable = createAbility((Class) => class extends controllable(Class) {
    constructor() {
        super();
        actionables.add(this);
        observeElementForTags(this);
    }
    [attachShadowCallback](root) {
        super[attachShadowCallback]?.(root);
        observeElementForTags(root);
    }
});
//# sourceMappingURL=actionable.js.map